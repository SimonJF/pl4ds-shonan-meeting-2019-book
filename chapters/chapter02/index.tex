%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% chapter02 - Behavioral Types
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% >>>>>>>>>>>>>>> PLEASE NOTE <<<<<<<<<<<<<<<
%
% This file is not stand-alone compileable as it is, to make it compileable while writing uncomment the preamble below.
% In this case, you also have to uncomment the begin/end document statements.
% You can outcomment the preamble and the begin/end document statements again or erase them when handing in your contribution.
%
% If you use BibTex for your bibliography, please use \putbib[bibliography] to print your reference (see end of this file).
%
% you can use paths relative to your chapter dir, e.g. \figure{assets/fig1}.
%
% >>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% you can uncomment the following preamble during development to make this file compileable.
%% Note that you need the svmult.cs file inside your chapter root dir to make this work.
%% Also note that if you need additional packages etc., you can add them here, but please
%% mark them somehow so the editor of this book knows you need them in the final book.
%% When you hand in your contribution, please uncomment or remove the preamble again.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% start of preamble
\documentclass[
graybox,
envcountchap,
%natbib
]{svmult}

\usepackage[utf8]{inputenc}
%\usepackage{type1cm}        % activate if the above 3 fonts are
% not available on your system

\usepackage{makeidx}         % allows index generation
\usepackage{graphicx}        % standard LaTeX graphics tool
% when including figure files
\usepackage{multicol}        % used for the two-column index
\usepackage[bottom]{footmisc}% places footnotes at page bottom

\usepackage{newtxtext}       %
\usepackage{newtxmath}       % selects Times Roman as basic font

% \usepackage{natbib}
\usepackage{footmisc}

%% Additional packages added. Add necessary packages here.
%\usepackage[english]{babel}
\usepackage{siunitx}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{xcolor}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{url}
\usepackage{mathtools}
\usepackage{lipsum}
\usepackage{import}
\usepackage{bibunits}
\usepackage{acronym}
\usepackage[nottoc]{tocbibind}
\usepackage{numberpt}

\newcommand{\todo}[1]{{\noindent\small\color{red} \framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textbf{TODO:} #1}}}}

\newcommand*{\CHAPTERSROOT}{../.}	% root path for chapters.
\newcommand*{\chapterprefix}{02}	% your chapter number.

\newcommand{\mkwd}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\defeq}{\triangleq}

\makeindex % used for the subject index
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% end of preamble

%% uncomment the \begin{document} statement to make this file stand-alone compileable.
\begin{document}

\begin{bibunit}

	\title*{Behavioural Types for Distribution}
	\author{Simon Fowler and Keigo Imai}

	\institute{
		Simon Fowler \at University of Edinburgh, United Kingdom, \email{simon.fowler@ed.ac.uk}
		\and Keigo Imai \at Gifu University, Japan, \email{keigoi@gifu-u.ac.jp}
		\and Vasco Vasconcelos \at University of Lisbon, Portugal, \email{vmvasconcelos@ciencias.ulisboa.pt}
		\and Heather Miller \at Northeastern University, USA, \email{heather.miller@cs.cmu.edu}
		\and Nobuko Yoshida \at Imperial College London, United Kingdom, \email{n.yoshida@imperial.ac.uk}
	}
	\maketitle

	\abstract{Please place your abstract here.}

	%% content
  \section{Introduction}


  \todo{yadayada}

  Following our discussions at the meeting which were centred around
  communication amongst distributed systems, and in particular noting that
  communication is a central concern in distributed systems, we concentrate
  particularly on behavioural type systems for communication protocols.

  Furthermore, while there has been extensive work on the behavioural typing
  disciplines described in this chapter, we restrict our attention purely to
  work which pertains explicitly to the interaction between behavioural types
  and distribution.

  \section{Background}
  \subsection{Behavioural Types}

  Much like data types encode the shape of data, behavioural types encode the
  behaviour of an application. Type systems allow an application developer to
  catch errors earlier in the development cycle: as an example, using a type
  system we can ensure undefined operations such as adding an integer to a
  Boolean value, or storing a string in an integer array, are ruled out before a
  program is executed.

  While data types can rule out errors such as adding $5$ and \mkwd{true},
  behavioural types can rule out more semantic errors, such as forgetting to
  close an open file handle, or failure to follow a communication protocol.

  \todo{Non-session type example (file system?)}

  \subsection{Session Types}
  Session types are a particularly well-known subclass of behavioural type
  system, which type an endpoint of a communication channel. A communication
  channel is an entity which allows communication between processes which hold
  an \emph{endpoint} to the channel.

  Perhaps the most basic type system for a communication channel endpoint is a
  channel which can send or receive a single type of value. Such type systems
  are inspired by the typed $\pi$-calculus, and have been used first in research
  languages such as Pict~\cite{XXX}, and more recently in widely-adopted
  languages such as Go~\cite{XXX}.

  For example, we could create a channel with type:
  \[
    \mkwd{Chan}(\mkwd{Int})
  \]
  which could send or receive integers; an attempt to send a string would result
  in a compile-time error.

  To illustrate the use of channels, in the following program, the
  main thread creates a channel and then spawns off a child thread. The main
  then then sends two integers along the channel, which are received by the
  child thread. The child thread subsequently sends the sum of the two integers,
  which is received by the parent thread:

  \todo{Write out example}

  However, even this tiny example is prone to multiple semantic errors: if the
  main thread only sends one integer and receives, there is a deadlock, and the
  program hangs forever. The same result happens if the main thread tries to
  receive; or if the main thread tries to send three integers; or if the child
  thread attempts to send before receiving; to name but a few. All of these
  semantic errors boil down to the program not satisfying an
  informally-specified protocol, which cannot be checked for correctness.

  \emph{Session types} allow us to generalise this type to be more descriptive.
  We can assign the channel endpoint for the main thread the following session
  type:

  \[
    \mkwd{AdditionServer} \defeq
    \mkwd{Chan}{{!}\mkwd{Int}.{!}\mkwd{Int}.{?}\mkwd{Int}}.\mkwd{End}
  \]
  (In the remainder of the chapter, we omit the $\mkwd{Chan}$ annotation when it
  is clear that we are discussing session-typed channels.)

  \todo{Description}

  The session endpoint given to the child process is as follows:
  \[
    \mkwd{AdditionClient} \defeq
    \mkwd{Chan}{{?}\mkwd{Int}.{?}\mkwd{Int}.{!}\mkwd{Int}}.\mkwd{End}
  \]

  Where the server sends, the client receives, and where the server receives,
  the client sends. This \emph{duality} between client and server ensures that
  the two ends of the channel implement the protocol and communicate safely.

  \todo{GV example of the process, discussion of linearity}

  To safely implement session types, we require some form of \emph{linearity},
  generally in the form of a linear type system. This proves to be the main
  hurdle to overcome when implementing session types in programming languages.

  \subsubsection{Multiparty Session Types}

  \todo{Probably the two-buyer example}

  \section{Behavioural Types and Distribution}

  \subsection{Session Channels}
  Session types are designed as type system for channel endpoints.
  In addition to sending values, we can also send channel endpoints themselves;
  a technique known as \emph{delegation}. Unfortunately, this mobility of
  endpoints leads to difficulties in the distributed setting.

  \paragraph{Synchrony and asynchrony.}
  The $\pi$-calculus involves \emph{synchronous} communication: two peers
  \emph{rendezvous} over a channel in order to communicate. Communication cannot
  occur until one peer is sending, and one peer is receiving, and execution
  cannot progres until the communication is complete. \emph{Asynchronous}
  communication allows send actions to communicate immediately, whereas receive
  actions complete immediately if a value is available but block otherwise.
  Asynchronous communication is usually implemented using a buffer.


  \subsubsection{Difficulties}\label{sec:distrib-deleg:difficulties}
  \todo{Describe distributed delegation algorithms}
  \subsubsection{Na\"ive approaches}
  \todo{Indefinite redirection, etc.}
  \subsubsection{Distributed Delegation Algorithms}
  \todo{Summarise Hu et al., 2008}

  \subsubsection{Continuation-passing Approaches}
  \todo{Summarise Scalas and Yoshida, 2016, Scalas et al., 2017}

  \subsection{Behavioural types for Actor Systems}
  The \emph{actor model} was introduced as a formalism for artificial
  intelligence by~\citet{HewittBS73:actors}. An actor is an entity with a
  unique identifier which upon receiving a message can perform
  three actions: it can send a finite set of messages to other actors; spawn a
  finite set of new actors; and change how it reacts to a new message being
  received.

  \citet{Agha90:actors} was first to investigate the actor model as a formalism
  for disributed systems. The actor model is particularly appealing since
  process IDs can be used to \emph{send} messages, but the capability to
  \emph{receive} messages is associated uniquely with an actor. In turn, this
  restriction sidesteps the issues described in
  Section~\ref{sec:distrib-deleg:difficulties}.
  This asymmetry is captured by Figure~\ref{fig:channels-vs-mailboxes} (Figure
  as shown by~\citet{FowlerLW17:mm}). Figure~\ref{fig:channels-vs-mailboxes:a}
  shows the communication patterns allowed by three process $P_1$, $P_2$, and
  $P_3$, over a channel: given that each process has access to the channel,
  each process can use the channel to send a message to any of the other
  processes. Figure~\ref{fig:channels-vs-maiboxes:b} shows the communication
  patterns associated with process $P_2$ as an actor process: given the process
  ID of $P_2$, all processes can send $P_2$ a message, but only $P_2$ can
  receive messages.

  \subsubsection{The Challenges of Typed Mailboxes}
  Actor communication is asynchronous. When implementing actors, an
  implementation technique is to associate each process with an incoming message
  queue, or \emph{mailbox}. While adding types to channels is entirely
  straightforward, adding types to mailboxes is substantially more challenging.


  \subsubsection{Featherweight Erlang}
  \subsubsection{Runtime Monitoring}
  \subsubsection{Mailbox Types}

  \section{Future Directions}
  \subsection{Finagle}
  \subsection{Failure handling and fault tolerance}

  \section{Conclusion}

	Please place your content here. See the sample template chapter for further reference on how you could style your content here.

	%% content

	\section*{Appendix}\label{appendix}

	Please place your appendix content here, if applicable.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%% For your bibliography, you should use a bibtex .bib file and include it here.
	%% Note that the final reference lists styling might differ because it'll be styled in unified book layout.

	% \biblstarthook{
	%	text inserted here will be printed before the actual list of references, but only if there is at least one reference to %display. Delete this section if you don't need it.
	%}

	% \nocite{*}		%% uncomment if uncited references should be listed in the bibliography.

	%% uncomment and state path to your .bib to use a bibtex file as your bibliography.
	%% NOTE: relative paths don't work in \putbib => During development, you might delete the "\CHAPTERSROOT/chapter\chapterprefix/" part to refer to your bib file. When you're done, please make this path absolute by adding the prefix again.
	%%
	% \putbib[\CHAPTERSROOT/chapter\chapterprefix/bibliography] %

\end{bibunit}

%% uncomment the \end{document} statement to make this file stand-alone compileable.
\end{document}
