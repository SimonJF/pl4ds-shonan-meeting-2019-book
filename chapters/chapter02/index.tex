%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% chapter02 - Behavioral Types
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% >>>>>>>>>>>>>>> PLEASE NOTE <<<<<<<<<<<<<<<
%
% This file is not stand-alone compileable as it is, to make it compileable while writing uncomment the preamble below.
% In this case, you also have to uncomment the begin/end document statements.
% You can outcomment the preamble and the begin/end document statements again or erase them when handing in your contribution.
%
% If you use BibTex for your bibliography, please use \putbib[bibliography] to print your reference (see end of this file).
%
% you can use paths relative to your chapter dir, e.g. \figure{assets/fig1}.
%
% >>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% you can uncomment the following preamble during development to make this file compileable.
%% Note that you need the svmult.cs file inside your chapter root dir to make this work.
%% Also note that if you need additional packages etc., you can add them here, but please
%% mark them somehow so the editor of this book knows you need them in the final book.
%% When you hand in your contribution, please uncomment or remove the preamble again.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% start of preamble
\documentclass[
graybox,
envcountchap
]{svmult}

\input{preamble}
\makeindex % used for the subject index
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% end of preamble

%% uncomment the \begin{document} statement to make this file stand-alone compileable.
\begin{document}

\begin{bibunit}

	\title*{Behavioural Types for Distribution}
	\author{Simon Fowler and Keigo Imai}

	\institute{
		Simon Fowler \at University of Edinburgh, United Kingdom, \email{simon.fowler@ed.ac.uk}
		\and Keigo Imai \at Gifu University, Japan, \email{keigoi@gifu-u.ac.jp}
		\and Vasco Vasconcelos \at University of Lisbon, Portugal, \email{vmvasconcelos@ciencias.ulisboa.pt}
		\and Heather Miller \at Northeastern University, USA, \email{heather.miller@cs.cmu.edu}
		\and Nobuko Yoshida \at Imperial College London, United Kingdom, \email{n.yoshida@imperial.ac.uk}
	}
	\maketitle

	\abstract{Please place your abstract here.}

	%% content
  \section{Introduction}


  \todo{yadayada}

  Following our discussions at the meeting which were centred around
  communication amongst distributed systems, and in particular noting that
  communication is a central concern in distributed systems, we concentrate
  particularly on behavioural type systems for communication protocols.

  Furthermore, while there has been extensive work on the behavioural typing
  disciplines described in this chapter, we restrict our attention purely to
  work which pertains explicitly to the interaction between behavioural types
  and distribution.

  \section{Background}
  \subsection{Behavioural Types}

  Much like data types encode the shape of data, behavioural types encode the
  behaviour of an application. Type systems allow an application developer to
  catch errors earlier in the development cycle: as an example, using a type
  system we can ensure undefined operations such as adding an integer to a
  Boolean value, or storing a string in an integer array, are ruled out before a
  program is executed.

  While data types can rule out errors such as adding $5$ and \mkwd{true},
  behavioural types can rule out more semantic errors, such as forgetting to
  close an open file handle, or failure to follow a communication protocol.

  \todo{Non-session type example (file system?)}

  \subsection{Session Types}
  Session types are a particularly well-known subclass of behavioural type
  system, which type an endpoint of a communication channel. A communication
  channel is an entity which allows communication between processes which hold
  an \emph{endpoint} to the channel.

  Perhaps the most basic type system for a communication channel endpoint is a
  channel which can send or receive a single type of value. Such type systems
  are inspired by the typed $\pi$-calculus, and have been used first in research
  languages such as Pict~\cite{XXX}, and more recently in widely-adopted
  languages such as Go~\cite{XXX}.

  For example, we could create a channel with type:
  \[
    \mkwd{Chan}(\mkwd{Int})
  \]


  which could send or receive integers; an attempt to send a string would result
  in a compile-time error.

  To illustrate the use of channels, in the following program, the
  main thread creates a channel and then spawns off a child thread. The main
  then then sends two integers along the channel, which are received by the
  child thread. The child thread subsequently sends the sum of the two integers,
  which is received by the parent thread:

  \todo{Write out example}

  However, even this tiny example is prone to multiple semantic errors: if the
  main thread only sends one integer and receives, there is a deadlock, and the
  program hangs forever. The same result happens if the main thread tries to
  receive; or if the main thread tries to send three integers; or if the child
  thread attempts to send before receiving; to name but a few. All of these
  semantic errors boil down to the program not satisfying an
  informally-specified protocol, which cannot be checked for correctness.

  \emph{Session types} allow us to generalise this type to be more descriptive.
  We can assign the channel endpoint for the main thread the following session
  type:

  \[
    \mkwd{AdditionServer} \defeq
    \mkwd{Chan}{{!}\mkwd{Int}.{!}\mkwd{Int}.{?}\mkwd{Int}}.\mkwd{End}
  \]
  (In the remainder of the chapter, we omit the $\mkwd{Chan}$ annotation when it
  is clear that we are discussing session-typed channels.)

  \todo{Description}

  The session endpoint given to the child process is as follows:
  \[
    \mkwd{AdditionClient} \defeq
    \mkwd{Chan}{{?}\mkwd{Int}.{?}\mkwd{Int}.{!}\mkwd{Int}}.\mkwd{End}
  \]

  Where the server sends, the client receives, and where the server receives,
  the client sends. This \emph{duality} between client and server ensures that
  the two ends of the channel implement the protocol and communicate safely.

  \todo{GV example of the process, discussion of linearity}

  To safely implement session types, we require some form of \emph{linearity},
  generally in the form of a linear type system. This proves to be the main
  hurdle to overcome when implementing session types in programming languages.

  \subsubsection{Multiparty Session Types}

  \todo{Probably the two-buyer example}

  \section{Behavioural Types and Distribution}

  \subsection{Session Channels}
  Session types are designed as type system for channel endpoints.
  In addition to sending values, we can also send channel endpoints themselves;
  a technique known as \emph{delegation}. Unfortunately, this mobility of
  endpoints leads to difficulties in the distributed setting.

  \mypar{Synchrony and asynchrony.}
  The $\pi$-calculus involves \emph{synchronous} communication: two peers
  \emph{rendezvous} over a channel in order to communicate. Communication cannot
  occur until one peer is sending, and one peer is receiving, and execution
  cannot progres until the communication is complete. \emph{Asynchronous}
  communication allows send actions to communicate immediately, whereas receive
  actions complete immediately if a value is available but block otherwise.
  Asynchronous communication is usually implemented using a buffer.


  \subsubsection{Difficulties}\label{sec:distrib-deleg:difficulties}
  \todo{Describe distributed delegation algorithms}
  \subsubsection{Na\"ive approaches}
  \todo{Indefinite redirection, etc.}
  \subsubsection{Distributed Delegation Algorithms}
  \todo{Summarise Hu et al., 2008}

  \subsubsection{Continuation-passing Approaches}
  \todo{Summarise Scalas and Yoshida, 2016, Scalas et al., 2017}

  \subsection{Behavioural types for Actor Systems}
  The \emph{actor model} was introduced as a formalism for artificial
  intelligence by Hewitt et al.~\cite{HewittBS73:actors}. An actor is an entity with a
  unique identifier which upon receiving a message can perform
  three actions: it can send a finite set of messages to other actors; spawn a
  finite set of new actors; and change how it reacts to a new message being
  received.

  \input{fig/chans-mailboxes}

  Agha~\cite{Agha90:actors} was first to investigate the actor model as a formalism
  for disributed systems. The actor model is particularly appealing since
  process IDs can be used to \emph{send} messages, but the capability to
  \emph{receive} messages is associated uniquely with an actor. In turn, this
  restriction sidesteps the issues described in
  Section~\ref{sec:distrib-deleg:difficulties}.
  This asymmetry is captured by Figure~\ref{fig:bt:channels-vs-mailboxes} (Figure
  as shown by Fowler et al.~\cite{FowlerLW17:mm}). Figure~\ref{fig:bt:channels-vs-mailboxes:a}
  shows the communication patterns allowed by three process $P_1$, $P_2$, and
  $P_3$, over a channel: given that each process has access to the channel,
  each process can use the channel to send a message to any of the other
  processes. Figure~\ref{fig:bt:channels-vs-mailboxes:b} shows the communication
  patterns associated with process $P_2$ as an actor process: given the process
  ID of $P_2$, all processes can send $P_2$ a message, but only $P_2$ can
  receive messages.

  \mypar{The Challenges of Typed Mailboxes}
  Actor communication is asynchronous. When implementing actors, an
  implementation technique is to associate each process with an incoming message
  queue, or \emph{mailbox}. While adding types to channels is entirely
  straightforward, adding types to mailboxes is substantially more challenging.

  Most implementations of actor-like communication, such as processes in
  Erlang~\cite{Armstrong10:erlang} or the native actor libraries for
  Scala~\cite{HallerO09:actors}, provide untyped mailboxes.
  %
  Typed mailboxes were first investigated by~He et al.~\cite{HeWT14:actors}, who
  introduced a typed extension of Akka, called TAkka. The authors highlighted
  the \emph{type pollution} problem, aparticular challenge with typed mailboxes
  arising due to the coarser granularity of typing.

  \begin{figure}
    \centering
    \includegraphics[width=0.75\textwidth]{img/type-pollution-example.pdf}
    \caption{Type Pollution}
    \label{fig:bt:type-pollution}
  \end{figure}

  To demonstrate this,
  consider the scenario shown in Figure~\ref{fig:bt:type-pollution}. A client
  wishes to connect to a chat room, modelled by a \lstinline+ChatRoom+ actor. It
  firstly sends a \lstinline+joinRequest+ message to the \lstinline+ChatServer+
  actor, which forwards the request to the appropriate \lstinline+ChatRoom+
  actor. The \lstinline+ChatRoom+ actor responds with a \lstinline+joinResponse+
  message, which is then forwarded to the client. We can assign the following
  mailbox types:


  \begin{itemize}
    \item \lstinline|Client : ActorRef(joinResponse)|
    \item \lstinline|ChatServer : ActorRef(joinRequest + joinResponse)|
    \item \lstinline|ChatRoom : ActorRef(joinRequest)|
  \end{itemize}

  Note in particular that the \lstinline+ChatServer+ must be able to handle both
  the \lstinline+joinRequest+ \emph{and} the \lstinline+joinResponse+ messages.
  Na\"ively implemented, this would result in a complete loss of modularity:
  each actor would be aware of \emph{every} message which could be received by
  every other actor, and worse, would need to use the exact same sum injection.
  Any small changes would make the program ill-typed.

  He et al.~\cite{HeWT14:actors} address type pollution by making use of subtyping, making
  actor references contravariant in their message type. Using a similar
  approach, the widely-adopted Akka framework~\cite{akka} has recently
  transitioned to typed actor references; the first major actor framework to do so.

  Fowler et al.~\cite{FowlerLW17:mm} study typed actors formally, and formally investigate
  type- and semantics-preserving translations between the two communication
  models. In particular, the type pollution problem means that in order to
  translate from typed channels into typed actors, one must either assign the
  same type to every channel in the system, or use a synchronisation mechanism
  such as futures.

  \mypar{A na\"ive behavioural type system for mailboxes.}
  As---unlike channels---mailboxes are unidirectional, the na\"ive extension is
  to generalise an actor's mailbox type to receiving a \emph{sequence} of types.
  Letting $A, B$ range over types, $V$ range over values, and $M$ range over
  terms, we might envisage actor references of type $\pid{\seq{A}}$ and the
  following two communication constructs:

  \begin{mathpar}
    \inferrule
      [TA-Receive]
      { }
      { \cdot \mid A \cdot \seq{A} \triangleright \calcwd{receive} : A \triangleleft \seq{A} }

    \inferrule
      [TA-Send]
      { \Gamma_1 \vdash V : A \\ \Gamma_2 \vdash W : \pid{A \cdot \seq{A}} }
      { \Gamma_1, \Gamma_2 \mid \seq{B} \triangleright \calcwd{send} \: M : \pid{A} \triangleleft \seq{B} }
  \end{mathpar}

  The $\Gamma \mid \seq{A} \triangleright M : B \triangleleft \seq{A}'$
  judgement can be read ``Under typing environment $\Gamma$, with the ability to
  receive a sequence of values with types $\seq{A}$, term $M$ has type $B$, and the
  remainder of the program has the ability to receive a sequence of values with
  type $\seq{A}'$. As values are pure, the value typing judgement $\Gamma \vdash
  V : A$ states that under type environment $\Gamma$, value $V$ has type $A$.

  Given the ability to receive values of types $A \cdot \seq{A}$, rule \textsc{TA-Receive}
  assigns $\calcwd{receive}$ type $A$, and allows $\seq{A}$ to be received in
  the remainder of the program. Correspondingly, rule \textsc{TA-Send} assigns
  term $\calcwd{send} \: V \: W$ type $\pid{A}$ if value $V$ has type $A$ and
  value $W$ is a process ID with type $\pid{A \cdot \seq{A}}$. Sending a message
  does not affect the types of value that the sender can receive.
  This formulation of a calculus with effectful operations with pre- and
  post-conditions is reminiscent of a parameterised
  monad~\cite{Atkey09:parameterised}.

  In order to make such a system sound, since $\calcwd{send}$ changes the type
  of a process ID, we need a linear type system. Unfortunately, such a system is
  far too restrictive to use in practice: as a gauge, there is no obvious
  translation from a standard channel-based session calculus into the above
  behavioural type system.

  In the remainder of this section, we survey various approaches to assigning
  behavioural types to actor-like systems.

  \subsubsection{Featherweight Erlang}
  Erlang~\cite{Armstrong10:erlang} is 

  \subsubsection{Runtime Monitoring}

  \subsubsection{Mailbox Types}

  \section{Future Directions}
  \subsection{Finagle}
  \subsection{Failure handling and fault tolerance}

  \section{Conclusion}

	Please place your content here. See the sample template chapter for further reference on how you could style your content here.

	%% content

	\section*{Appendix}\label{appendix}

	Please place your appendix content here, if applicable.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%% For your bibliography, you should use a bibtex .bib file and include it here.
	%% Note that the final reference lists styling might differ because it'll be styled in unified book layout.

	% \biblstarthook{
	%	text inserted here will be printed before the actual list of references, but only if there is at least one reference to %display. Delete this section if you don't need it.
	%}

	% \nocite{*}		%% uncomment if uncited references should be listed in the bibliography.

	%% uncomment and state path to your .bib to use a bibtex file as your bibliography.
	%% NOTE: relative paths don't work in \putbib => During development, you might delete the "\CHAPTERSROOT/chapter\chapterprefix/" part to refer to your bib file. When you're done, please make this path absolute by adding the prefix again.
	%%
	%\putbib[\CHAPTERSROOT/chapter\chapterprefix/bibliography] %
	\putbib[bibliography] %

\end{bibunit}

%% uncomment the \end{document} statement to make this file stand-alone compileable.
\end{document}
